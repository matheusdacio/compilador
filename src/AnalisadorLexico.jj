// AnalisadorLexico.jj (Versão que não usa LEXICAL_STATES)
options {
    STATIC = false;
    IGNORE_CASE = true;
}

PARSER_BEGIN(AnalisadorLexico)

import java.io.*;
public class AnalisadorLexico {
    public static void main(String args[]) throws ParseException, TokenMgrError, FileNotFoundException {
        try {
            AnalisadorLexico parser = new AnalisadorLexico(new FileInputStream(args[0]));
            Token t;
            do {
                t = parser.getNextToken();
                System.out.printf("Lexema: %s, Categoria: %s%n", t.image, AnalisadorLexico.tokenImage[t.kind]);
            } while (t.kind != EOF);
        } catch (FileNotFoundException e) {
            System.err.println("Arquivo não encontrado.");
        } catch (TokenMgrError e) {
            System.err.println("ERRO LEXICO: " + e.getMessage());
        }
    }
}

PARSER_END(AnalisadorLexico)

SKIP : {
    " " | "\t" | "\n" | "\r"
}

SPECIAL_TOKEN : {
    < LINE_COMMENT: "//" (~["\n", "\r"])* >
|
    < BLOCK_COMMENT: "/*" (~["*"] | "*" ~["/"])* "*/" >
}

TOKEN : {
    <BEGIN: "begin"> | <DEFINE: "define"> | <START: "start"> | <END: "end"> | <SET: "set"> |
    <READ: "read"> | <SHOW: "show"> | <IF: "if"> | <THEN: "then"> | <ELSE: "else"> |
    <LOOP: "loop"> | <WHILE: "while"> | <NUM: "num"> | <REAL: "real"> | <TEXT: "text"> |
    <FLAG: "flag"> | <TRUE: "true"> | <FALSE: "false">
}

TOKEN : {
    // ERRO 1: Identificador que começa com dígito. (Prioridade máxima de erro)
    <ERRO_ID_INICIA_COM_DIGITO: (<DIGITO>)+ ((<LETRA> | <DIGITO> | "_")*) >
    |
    // ERRO 2: Identificador com dígitos consecutivos.
    // Esta regra precisa vir ANTES do erro de "termina com dígito".
    <ERRO_ID_DIGITOS_CONSECUTIVOS:
      (<LETRA> | "_")
      (<LETRA> | <DIGITO> | "_")*
      <DIGITO> <DIGITO>
      (<LETRA> | <DIGITO> | "_")*
    >
    |
    // ERRO 3: Identificador que termina com dígito.
    // Esta regra só é alcançada se a de cima falhar.
    <ERRO_ID_TERMINA_COM_DIGITO: (<LETRA> | "_") (<LETRA> | <DIGITO> | "_")* <DIGITO> >
    |
    // REGRA VÁLIDA: Se NENHUM erro acima foi detectado, o lexema é um identificador válido.
    <IDENTIFIER: (<LETRA> | "_") ((<LETRA> | <DIGITO> | "_")*)>
    |
    <#LETRA: ["a"-"z", "A"-"Z"]>
    |
    <#DIGITO: ["0"-"9"]>
}

TOKEN : {
    // --- ERROS DE NÚMEROS REAIS ---

    //Parte fracionária com 3 ou mais dígitos.
    <ERRO_REAL_FRACAO_LONGA: (<DIGITO>)+ "." <DIGITO><DIGITO><DIGITO>(<DIGITO>)* >
    |
    //Parte inteira com 5 ou mais dígitos.
    <ERRO_REAL_INTEIRO_LONGO: <DIGITO><DIGITO><DIGITO><DIGITO><DIGITO>(<DIGITO>)* "." (<DIGITO>)+ >
    |
    //termina com um ponto, mas sem a parte fracionária.
    <ERRO_REAL_INCOMPLETO: (<DIGITO>)+ "." >
    |
    //inteiro com 4 ou mais dígitos.
    <ERRO_INT_LONGO: <DIGITO><DIGITO><DIGITO><DIGITO>(<DIGITO>)* >
    |
    <CONST_REAL: <DIGITO>(<DIGITO>)?(<DIGITO>)?(<DIGITO>)? "." <DIGITO>(<DIGITO>)? >
    |
    <CONST_INT: <DIGITO>(<DIGITO>)?(<DIGITO>)? >
    |
    <CONST_LITERAL: "\"" (~["\"", "\n", "\r"])* "\"" | "'" (~["'", "\n", "\r"])* "'" >
    |
    <ERRO_LITERAL: "\"" (~["\"", "\n", "\r"])* | "'" (~["'", "\n", "\r"])* >
}

TOKEN : {
      < OP_REL_LTLT_EQ: "<<=" > | < OP_REL_GTGT_EQ: ">>=" > | < OP_REL_EQ: "==" > | < OP_REL_NEQ: "!=" > |
      < OP_REL_LTLT:    "<<" > | < OP_REL_GTGT:    ">>" > | < OP_ARIT_POW: "**" > | < OP_ARIT_DIVINT: "%%" > |
      < OP_ARIT_SUM:    "+" > | < OP_ARIT_SUB:    "-" > | < OP_ARIT_MUL:    "*" > | < OP_ARIT_DIV:    "/" > |
      < OP_ARIT_MOD:    "%" > | < OP_LOGIC_AND: "&" > | < OP_LOGIC_OR:  "|" > | < OP_LOGIC_NOT: "!" > |
      < ASSIGN:    "=" > | < SEMICOLON: ";" > | < COMMA:     "," > | < LPAREN:    "(" > | < RPAREN:    ")" > |
      < LBRACKET:  "[" > | < RBRACKET:  "]" > | < LBRACE:    "{" > | < RBRACE:    "}" > | < COLON:    ":" > | <DOT: "." >
}

TOKEN : {
    <ERRO_LEXICO: ~[] >
}