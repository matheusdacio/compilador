options {
    STATIC = false;
    IGNORE_CASE = true;
}

PARSER_BEGIN(AnalisadorLexico)

import java.io.*;

public class AnalisadorLexico {

    private ErrorHandler errorHandler;

    public AnalisadorLexico(Reader stream, ErrorHandler handler) {
        this(stream);
        this.errorHandler = handler;
    }

    public static void main(String args[]) throws TokenMgrError, FileNotFoundException, ParseException {
        try {
            if (args.length == 0) {
                System.err.println("Uso: java AnalisadorLexico <arquivo-fonte>");
                return;
            }
            ErrorHandler consoleHandler = new ErrorHandler();
            Reader reader = new InputStreamReader(new FileInputStream(args[0]));
            AnalisadorLexico parser = new AnalisadorLexico(reader, consoleHandler);
            System.out.println("=== Iniciando análise léxica e sintática ===");
            parser.programa();
            if (consoleHandler.hasErrors()) {
                System.out.println("\n=== Erros encontrados: ===");
                for (String error : consoleHandler.getErrorMessages()) {
                    System.err.println("- " + error);
                }
            } else {
                System.out.println("\n=== Análise concluída com sucesso ===");
            }
        } catch (FileNotFoundException e) {
            System.err.println("Arquivo não encontrado: " + e.getMessage());
        } catch (TokenMgrError e) {
            System.err.println("ERRO LÉXICO FATAL: " + e.getMessage());
        }
    }
}

PARSER_END(AnalisadorLexico)

// PRODUÇÕES SINTÁTICAS

void programa() :
{}
{
    try {
        <BEGIN> inicio() definicao() <START> comandos() <END> <DOT>
    } catch (ParseException e) {
        if (errorHandler != null) {
            errorHandler.processParseException(e, "na estrutura principal do programa");
        }
    }
}

void inicio() : {} { [ <IDENTIFIER> ] }

void definicao() : {} {
    [
        <DEFINE>
        try {
            lista_dv()
        } catch (ParseException e) {
            if (errorHandler != null) {
                errorHandler.processParseException(e, "na seção de declarações");
            }
            while (true) {
                Token t = getToken(1);
                if (t.kind == START || t.kind == EOF) break;
                getNextToken();
            }
        }
    ]
}

// Declarações de variáveis

void lista_dv() : {} { (declaracao_variaveis())+ }

void declaracao_variaveis() : {} {
    try {
        lista_identificadores() <COLON> tipo() declaracao_variaveis_opcional() <SEMICOLON>
    } catch (ParseException e) {
        if (errorHandler != null) {
            Token t = getToken(1);
            if (t.image.equals("start") || t.image.equals("START")) {
                errorHandler.addError("Erro: esperado ';' ao final da declaração de variável antes de 'start' (linha " + t.beginLine + ", coluna " + t.beginColumn + ")");
            } else {
                errorHandler.processParseException(e, "em uma declaração de variável");
            }
        }
        while (true) {
            Token t = getToken(1);
            if (t.kind == SEMICOLON || t.kind == IDENTIFIER || t.kind == START || t.kind == EOF) {
                if (t.kind == SEMICOLON) getNextToken();
                break;
            }
            getNextToken();
        }
    }
}

void declaracao_variaveis_opcional() : {} {
    ( <ASSIGN> valor() ) |
    ( <LBRACKET> <CONST_INT> <RBRACKET> ( <ASSIGN> <LBRACE> lista_valores() <RBRACE> )? ) |
    {}
}

void lista_identificadores() : {} { <IDENTIFIER> ( <COMMA> <IDENTIFIER> )* }
void lista_valores() : {} { valor() ( <COMMA> valor() )* }
void tipo() : {} { <NUM> | <REAL> | <TEXT> | <FLAG> }
void valor() : {} { <CONST_INT> | <CONST_REAL> | <CONST_LITERAL> | <TRUE> | <FALSE> }

// Comandos

void comandos() :
{}
{
    ( comando() )+
}

void comando() :
{}
{
    try {
        (
            comando_atribuicao() |
            comando_entrada() |
            comando_saida() |
            comando_selecao() |
            comando_repeticao()
        )
    } catch (ParseException e) {
        if (errorHandler != null) {
            errorHandler.processParseException(e, "em um comando");
        }
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != EOF && t.kind != SEMICOLON && t.kind != END);
    }
}

void comando_atribuicao() : {} { <SET> <IDENTIFIER> ( <ASSIGN> expressao() <SEMICOLON> | <LBRACKET> expressao() <RBRACKET> <ASSIGN> expressao() <SEMICOLON> ) }
void comando_entrada() : {} { <READ> <LPAREN> <IDENTIFIER> ( <LBRACKET> expressao() <RBRACKET> )? <RPAREN> <SEMICOLON> }
void comando_saida() : {} { <SHOW> <LPAREN> lista_elementos_saida() <RPAREN> <SEMICOLON> }
void lista_elementos_saida() : {} { elemento_saida() ( <COMMA> elemento_saida() )* }
void elemento_saida() : {} { <IDENTIFIER> | <CONST_INT> | <CONST_REAL> | <CONST_LITERAL> }
void comando_selecao() : {} { <IF> expressao() <THEN> comandos() ( <ELSE> comandos() )? <END> <SEMICOLON> }
void comando_repeticao() : {} { <LOOP> <WHILE> expressao() comandos() <END> <SEMICOLON> }

void expressao() : {} { expressao_arit_log() expressao2() }
void expressao2() : {} { ( <OP_REL_EQ> | <OP_REL_NEQ> | <OP_REL_LTLT> | <OP_REL_GTGT> | <OP_REL_LTLT_EQ> | <OP_REL_GTGT_EQ> ) expressao_arit_log() | {} }
void expressao_arit_log() : {} { termo2() menor_prioridade() }
void menor_prioridade() : {} { ( <OP_ARIT_SUM> | <OP_ARIT_SUB> | <OP_LOGIC_OR> ) termo2() menor_prioridade() | {} }
void termo2() : {} { termo1() media_prioridade() }
void media_prioridade() : {} { ( <OP_ARIT_MUL> | <OP_ARIT_DIV> | <OP_ARIT_MOD> | <OP_ARIT_DIVINT> | <OP_LOGIC_AND> ) termo1() media_prioridade() | {} }
void termo1() : {} { elemento() maior_prioridade() }
void maior_prioridade() : {} { <OP_ARIT_POW> elemento() maior_prioridade() | {} }
void elemento() : {} { <IDENTIFIER> | <CONST_INT> | <CONST_REAL> | <CONST_LITERAL> | <TRUE> | <FALSE> | <LPAREN> expressao() <RPAREN> | <OP_LOGIC_NOT> <LPAREN> expressao() <RPAREN> }

// REGRAS LÉXICAS (TOKENS)

SKIP : { " " | "\t" | "\n" | "\r" }

SPECIAL_TOKEN : {
    < LINE_COMMENT: "//" (~["\n", "\r"])* > |
    < BLOCK_COMMENT: "/*" (~["*"] | "*" ~["/"])* "*/" >
}

// --- PALAVRAS RESERVADAS ---
TOKEN : {
    <BEGIN: "begin"> |
    <DEFINE: "define"> | <START: "start"> | <END: "end"> | <SET: "set"> |
    <READ: "read"> | <SHOW: "show"> |
    <IF: "if"> | <THEN: "then"> | <ELSE: "else"> |
    <LOOP: "loop"> | <WHILE: "while"> | <NUM: "num"> |
    <REAL: "real"> | <TEXT: "text"> |
    <FLAG: "flag"> | <TRUE: "true"> |
    <FALSE: "false">
}

// --- CONSTANTES E ERROS LÉXICOS ---
TOKEN : {
    <CONST_REAL: <DIGITO>(<DIGITO>)?(<DIGITO>)?(<DIGITO>)? "." <DIGITO>(<DIGITO>)? >
|   <CONST_INT: <DIGITO>(<DIGITO>)?(<DIGITO>)? >
|   <CONST_LITERAL: "\"" (~["\"", "\n", "\r"])* "\"" | "'" (~["'", "\n", "\r"])* "'" >
|   <ERRO_REAL_FRACAO_LONGA: (<DIGITO>)+ "." <DIGITO><DIGITO><DIGITO>(<DIGITO>)* >
|   <ERRO_REAL_INTEIRO_LONGO: <DIGITO><DIGITO><DIGITO><DIGITO><DIGITO>(<DIGITO>)* "." (<DIGITO>)+ >
|   <ERRO_REAL_INCOMPLETO: (<DIGITO>)+ "." >
|   <ERRO_INT_LONGO: <DIGITO><DIGITO><DIGITO><DIGITO>(<DIGITO>)* >
}

// --- IDENTIFICADORES E ERROS DE ID ---
TOKEN : {
    <ERRO_ID_INICIA_COM_DIGITO: (<DIGITO>)+ (<LETRA> | "_") ((<LETRA> | <DIGITO> | "_")*) >
|   <ERRO_ID_DIGITOS_CONSECUTIVOS: (<LETRA> | "_")(<LETRA> | <DIGITO> | "_")* <DIGITO> <DIGITO> (<LETRA> | <DIGITO> | "_")* >
|   <ERRO_ID_TERMINA_COM_DIGITO: (<LETRA> | "_") (<LETRA> | <DIGITO> | "_")* <DIGITO> >
|   <IDENTIFIER: (<LETRA> | "_") ((<LETRA> | <DIGITO> | "_")*)>
|   <#LETRA: ["a"-"z", "A"-"Z"]>
|   <#DIGITO: ["0"-"9"]>
}

// --- OPERADORES E SÍMBOLOS ---
TOKEN : {
    < OP_REL_LTLT_EQ: "<<=" > | < OP_REL_GTGT_EQ: ">>=" > | < OP_REL_EQ: "==" > |
    < OP_REL_NEQ: "!=" > |
    < OP_REL_LTLT: "<<" > | < OP_REL_GTGT: ">>" > | < OP_ARIT_POW: "**" > |
    < OP_ARIT_DIVINT: "%%" > |
    < OP_ARIT_SUM: "+" > | < OP_ARIT_SUB: "-" > | < OP_ARIT_MUL: "*" > |
    < OP_ARIT_DIV: "/" > |
    < OP_ARIT_MOD: "%" > | < OP_LOGIC_AND: "&" > | < OP_LOGIC_OR: "|" > |
    < OP_LOGIC_NOT: "!" > |
    < ASSIGN: "=" > | < SEMICOLON: ";" > | < COMMA: "," > |
    < LPAREN: "(" > | < RPAREN: ")" > |
    < LBRACKET: "[" > | < RBRACKET: "]" > |
    < LBRACE: "{" > | < RBRACE: "}" > | < COLON: ":" > | <DOT: "." >
}

TOKEN : { <ERRO_LEXICO: ~[] > }